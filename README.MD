# 为了更好的开发,不得不规定一下战斗模型
### 已废弃
0. 找到下一个要行动的looter
1. 触发该looter的状态(每个都触发),直接受到effect影响
2. 攻击looter选择技能(1主动+N永久被动+N随机被动),选择攻击目标,返回对应每个目标受到的effect列表: {Looter: SkillEffect/PropertiesEffect}
3. 被攻击looter收到攻击影响,选择技能作防御(N永久被动+N随机被动),返回追加影响列表(减伤反伤什么的):List<SkillEffect/PropertiesEffect>
4. 被攻击looter受到effect列表影响
5. 攻击looter受到effect影响
6. 结束


# 另一个想法
### 已废弃
1. 所有的行动都通过响应式的方式来触发
2. 例如在战斗时,分为以下几个阶段:
   1. 准备战斗(触发状态)
   2. 攻击之前(选取主动技能和目标)
   3. 被攻击之前(执行自己的被动技能)
   4. 受到伤害(计算自己的血量减少)
   5. 受到伤害之后(通过自己的技能给自己或对方造成影响)
   6. 造成伤害后(触发被动效果)
   7. 结束战斗(引发钩子函数的执行)
3. 再细一点:
   1. 收到攻击命令后(敌人列表): 返回使用的技能和目标    输入:List<Looter>,输出:AttackChoiceContext
   2. 造成伤害后(目标,伤害值): 返回使用的技能和目标    输入:AffectDamageContext,输出:AttackChoiceContext
   3. 受到伤害前(来自谁,伤害值,来自什么技能): 返回使用的技能和目标    输入:DamageContext,输出:AttackChoiceContext
   4. 受到伤害后(来自哪,伤害值,来自什么技能): 返回使用的技能和目标    输入:DamageContext,输出:AttackChoiceContext
4. 被动技能每回合有触发次数限制
5. 伤害有类型,普通伤害和神圣伤害
6. 收到攻击命令后,调用自己的进攻方法(攻击准备-选主动技能,主动技能返回一个基础伤害对象,然后选择被动强化这个对象,调用对方的【受到攻击】接口)
7. 受到攻击接口触发,选择自己的弱化技能来对伤害进行弱化,然后计算伤害,回调自己的【受到伤害】接口,最后回调攻击者的【对敌人造成伤害接口】

# 修改模型吧
1. looter的属性有【基本属性】和【战斗属性】
2. 基本属性即HP,力量,敏捷等
3. 同时每种属性还有【持续】和【临时】两种类型，其中【临时】类型的属性在回合结束时清空
4. 战斗属性即攻击力、防御力、速度、暴击率、闪避率、附加伤害、伤害减免
5. 技能分为【主动技能】和【被动技能】
6. 被动技能分为【普通被动技能】和【触发被动技能】
7. 【普通被动技能】即直接添加面板的技能，它可以永久增加角色的基本属性或者战斗属性
8. 【触发被动技能】可以在某些特定场合发动，它会造成一些影响(比如反击,减抗等)
9. 战斗时:
   1. 调用双方的【回合开始】方法
   2. 调用角色的攻击方法
   3. 角色选择技能,并选择目标
   4. 调用【被动技能生效】方法，检查自己的所有【触发被动技能】是否满足生效条件(条件可以根据上下文来决定,上下文包括攻击者和被攻击者)，如果满足则发动(增加自己的伤害,减少对方防御)
   5. 选择的技能生效(主动技能生成一个Effect),调用对方的【受到攻击接口】
   6. 对方调用【被动技能生效】方法，检查自己的所有【触发被动技能】是否满足生效条件(条件可以根据上下文来决定,上下文包括攻击者和被攻击者,伤害Effect),如果满足则发动(增加自己防御,增加自己闪避)
   7. 计算并计算伤害(根据自己的【战斗属性】对伤害值进行增减)，并输出真正Effect
   8. 对方调用【被动技能生效】方法，检查自己的所有【触发被动技能】是否满足生效条件(条件可以根据上下文来决定,上下文包括攻击者和被攻击者,真正受到的Effect),如果满足则发动(回复自己血量)
   9. 回调攻击方的【攻击结束】方法
   10. 攻击方调用【被动技能生效】方法，检查自己的所有【触发被动技能】是否满足生效条件(条件可以根据上下文来决定,上下文包括攻击者和被攻击者,真正受到的Effect),如果满足则发动(吸血什么的)
   11. 调用双方的【回合结束】方法